MySql索引优化
索引很有用,但是它也是有成本的――它占内存,让写入变慢；
1.多列索引，使用最频繁的一列放最左边
2.like %a 百分号写左边会使索引失效 
3.尽量使用覆盖索引，查询的字段和索引列一致
4.对索引列进行运算导致索引失效,我所指的对索引列进行运算包括(+，-，*，/，!，!= 等)
5.is null, is not null 无法使用索引
6.字符串不加单引号索引失效
7.用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及到的索引都不会被用到
如果MySQL估计使用索引比全表扫描更慢，则不使用索引。
查询时字段数据类型不一致的话 不会用到索引。
是最左前缀原则, 即如果你创建一个联合索引, 那
这个索引的任何前缀都会用于查询, (col1, col2, col3)这个联合索引的所有前缀
就是(col1), (col1, col2), (col1, col2, col3), 包含这些列的查询都会启用索
引查询.
当遇到范围查询时, 就停止索引的匹配.
使用CURDATE()等函数不会用到查询缓存

myISAM:不支持事务，锁是表级别的，适合多读少写的场景，支持全文索引
innoDB:支持事务，行锁，不支持全文索引

合适的数据类型 小, 尽可能使用not null（不是not null会多占用1个字节）,尽量使用简单的数据类型，尽量少用text类型
避免索引重复和冗余
连接查询代替子查询
用orderby优化limit

使用int存储时间 利用FROM_UNIXTIME()和UNIX_TIMESTAMP()两个函数来进行转换
使用bigint存储IP地址 INET_ATON()和INET_NTOA()

垂直拆分：解决列多的问题
水平拆分：解决单表数据量过大的问题

MySQL InnoDB事务的隔离级别有四级，默认是“可重复读”（REPEATABLE READ）。

・未提交读（READUNCOMMITTED）。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）。

・提交读（READCOMMITTED）。本事务读取到的是最新的数据（其他事务提交后的）。问题是，在同一个事务里，前后两次相同的SELECT会读到不同的结果（不重复读）。

・可重复读（REPEATABLEREAD）。在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象（稍后解释）。

・串行化（SERIALIZABLE）。读操作会隐式获取共享锁，可以保证不同事务间的互斥。

四个级别逐渐增强，每个级别解决一个问题。

・脏读，最容易理解。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据。

・不重复读。解决了脏读后，会遇到，同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。

・幻读。解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会“惊奇的”发现了这些新数据，貌似之前读到的数据是“鬼影”一样的幻觉。

另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：Index Selectivity = Cardinality / #T显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的

在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

死锁的情况：
如果在事务中执行了一条不满足条件的update语句，则执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞

B树和B+树的区别在哪呢？

B+跟B树不同B+树的非叶子节点不保存键值对应的数据，这样使得B+树每个节点所能保存的键值大大增加；

B+树叶子节点保存了父节点的所有键值和键值对应的数据，每个叶子节点的键值从小到大链接；

B+树的根节点键值数量和其子节点个数相等;

B+的非叶子节点只进行数据索引，不会存实际的键值对应的数据，所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；

.js文件的编译：
头尾包装，传入exports,module,require,__filename,__dirname，然后通过vm.runInThisContext()执行 具有独立的上下文不会污染全局
.node文件的编译：
调用process.dlopen()执行
.json文件的编译：
通过fs读取json文件然后通过 JSON.parse()

process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果保存在链表中，process.nextTick()的回调函数会在一次循环中全部执行完，而setImmediate()每轮循环只会执行一个函数

内存限制：
64位1.4G 32位0.7G
v8垃圾回收算法：分代式

不会进行垃圾回收的情况：
闭包、内存当缓存、全局变量、global上挂属性、

计算密集型代码可以用fork开启子进程计算